<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap 5 -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  >
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css"
    rel="stylesheet"
  >

  <style>
    .player-bar {
      position: sticky;
      bottom: 0;
      z-index: 1030;
      background: #fff;
      border-top: 1px solid #ddd;
    }

    /* Keep hover the same (no flicker) */
    #autoplayToggle {
      background-color: #198754;
      border-color: #198754;
      color: #fff;
    }

    #autoplayToggle.off {
      background-color: #6c757d;
      border-color: #6c757d;
      color: #fff;
    }

    /* Optional: focus ring */
    #autoplayToggle:focus {
      box-shadow: 0 0 0 0.25rem rgba(25, 135, 84, 0.5);
    }
    audio {
      width: 100%;
    }
  </style>
</head>
<body class="bg-light">

<div class="container py-3">

  <div class="player-bar shadow-sm rounded p-3">

    <!-- Audio -->
    <audio id="player" controls playsinline class="mb-2">
      <source id="audioSource"
              src="https://raw.githubusercontent.com/gre785/audiobook/main/bbsl/1.mp3"
              type="audio/mpeg">
    </audio>

    <!-- Track label -->
    <div class="text-center large text-muted mb-2" id="trackLabel">
      1.mp3
    </div>

    <!-- Controls -->
    <div class="row g-2 align-items-center">

      <div class="col-6 col-md-2 d-grid">
        <button class="btn btn-outline-secondary btn-lg" onclick="playPrev()">
          <i class="bi bi-skip-backward-fill"></i>
        </button>
      </div>

      <div class="col-6 col-md-2 d-grid">
        <button class="btn btn-outline-secondary btn-lg" onclick="playNext()">
          <i class="bi bi-skip-forward-fill"></i>
        </button>
      </div>

      <div class="col-8 col-md-4">
        <input
          type="number"
          id="jumpInput"
          class="form-control form-control-lg"
          min="1"
          max="766"
          placeholder="Jump to (1–766)"
          inputmode="numeric"
        >
      </div>

      <div class="col-4 col-md-2 d-grid">
        <button class="btn btn-primary btn-lg" onclick="jumpTo()">
          Go
        </button>

      </div>

      <div class="col-12 col-md-2 d-grid">
        <button
          id="autoplayToggle"
          class="btn btn-outline-success btn-lg"
          onclick="toggleAutoplay()">
          ON
        </button>
      </div>

    </div>
  </div>
</div>

</body>
</html>



<script>
  const START = 1;
  const END = 766;
  const START_AT_SECONDS = 40;
  const STORAGE_KEY_TRACK = "audiobook_last_track";
  const STORAGE_KEY_TIME  = "audiobook_last_time";

  const baseUrl = "https://raw.githubusercontent.com/gre785/audiobook/main/bbsl/";
  const player = document.getElementById("player");
  const source = document.getElementById("audioSource");
  const label = document.getElementById("trackLabel");
  const jumpInput = document.getElementById("jumpInput");

  // Load last saved state
  let index = parseInt(localStorage.getItem(STORAGE_KEY_TRACK), 10) || START;
  let savedTime = parseFloat(localStorage.getItem(STORAGE_KEY_TIME)) || 0;
  const STORAGE_KEY_AUTOPLAY = "audiobook_autoplay_next";

  // default = ON
  let autoplayNext =
    localStorage.getItem(STORAGE_KEY_AUTOPLAY) !== "false";

  const autoplayBtn = document.getElementById("autoplayToggle");

  function updateAutoplayButton() {
    autoplayBtn.textContent = autoplayNext ? "ON" : "OFF";
    // Toggle outline class (green vs grey)
    autoplayBtn.classList.toggle("btn-outline-success", autoplayNext);
    autoplayBtn.classList.toggle("btn-outline-secondary", !autoplayNext);
    // Toggle an 'off' marker class which the CSS uses to set background to grey
    autoplayBtn.classList.toggle("off", !autoplayNext);
    // Ensure core btn classes are present
    if (!autoplayBtn.classList.contains("btn")) autoplayBtn.classList.add("btn");
    if (!autoplayBtn.classList.contains("btn-lg")) autoplayBtn.classList.add("btn-lg");
  }

  function toggleAutoplay() {
    autoplayNext = !autoplayNext;
    localStorage.setItem(STORAGE_KEY_AUTOPLAY, autoplayNext);
    updateAutoplayButton();
  }

  function loadTrack(i, time = 0) {
    index = i;
    source.src = baseUrl + index + ".mp3";
    label.textContent = index + ".mp3";
    player.load();
    player.volume = 0.25;
    player.preload = "auto";

    // Restore playback position once metadata is loaded
    player.onloadedmetadata = () => {
      if (time <= START_AT_SECONDS) {
        player.currentTime = Math.min(START_AT_SECONDS, player.duration || 0);
      }
      if (time > 0 && time < player.duration) {
        player.currentTime = time;
      }
    };
  }

  function playPrev() {
    if (index > START) {
      loadTrack(index - 1);
      player.play();
    }
  }

  function playNext() {
    if (index < END) {
      loadTrack(index + 1);
      player.play();
    }
  }

  function jumpTo() {
    const value = parseInt(jumpInput.value, 10);
    if (value >= START && value <= END) {
      loadTrack(value);
      player.play();
    } else {
      alert("Please enter a number between 1 and 766");
    }
  }

  // Save progress periodically
  player.addEventListener("timeupdate", () => {
    localStorage.setItem(STORAGE_KEY_TRACK, index);
    localStorage.setItem(STORAGE_KEY_TIME, player.currentTime);
  });

  // Auto-play next track when one ends
  player.addEventListener("ended", () => {
    localStorage.setItem(STORAGE_KEY_TIME, 0);

    if (!autoplayNext) return;

    if (index < END) {
      loadTrack(index + 1);
      player.play().catch(() => {
        console.log("Autoplay blocked, user interaction required");
      });
    }
  });

  player.addEventListener("volumechange", () => {
    localStorage.setItem("volume", player.volume);
  });
  // Initial load (resume last session)
  // Apply button state styling then load last track
  updateAutoplayButton();
  loadTrack(index, savedTime);

  // Pause player when the system's audio output devices change.
  // Uses the MediaDevices API 'devicechange' event where supported.
  let _prevAudioOutputIds = [];
  async function _getAudioOutputIds() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return [];
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices
        .filter(d => d.kind === 'audiooutput')
        .map(d => d.deviceId)
        .sort();
    } catch (e) {
      return [];
    }
  }

  (async () => {
    _prevAudioOutputIds = await _getAudioOutputIds();
  })();

  if (navigator.mediaDevices && typeof navigator.mediaDevices.addEventListener === 'function') {
    navigator.mediaDevices.addEventListener('devicechange', async () => {
      const newIds = await _getAudioOutputIds();
      // If the set of audio output devices changed, pause playback.
      if (JSON.stringify(newIds) !== JSON.stringify(_prevAudioOutputIds)) {
        _prevAudioOutputIds = newIds;
        if (!player.paused) {
          player.pause();
          console.log('Audio output device changed — player paused');
        }
      }
    });
  }

  // Polling fallback: some browsers don't emit 'devicechange' for audiooutput.
  // Periodically enumerate devices and compare IDs; pause when changed.
  let _devicePollInterval = null;
  function startDevicePoll() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
    // Start poll only if not already running
    if (_devicePollInterval) return;
    _devicePollInterval = setInterval(async () => {
      const newIds = await _getAudioOutputIds();
      if (JSON.stringify(newIds) !== JSON.stringify(_prevAudioOutputIds)) {
        _prevAudioOutputIds = newIds;
        if (!player.paused) {
          player.pause();
          console.log('Audio output device changed (poll) — player paused');
        }
      }
    }, 2000);
  }
  startDevicePoll();
  window.addEventListener('beforeunload', () => {
    if (_devicePollInterval) clearInterval(_devicePollInterval);
  });

  // If MediaDevices APIs are not available, inform in console (use local server/HTTPS for full support).
  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
    console.warn('navigator.mediaDevices.enumerateDevices not available. Device-change detection may not work. Serve file over HTTPS or localhost to enable device APIs.');
  }
</script>
